use anyhow::{anyhow, Result};
use clap::{Parser, ValueEnum};
use genanki_rs::{Deck, Field, Model, ModelType, Note, Template};
use indicatif::{ProgressBar, ProgressStyle};
use regex::Regex;
use reqwest::Client;
use scraper::{Html, Selector};
use std::sync::LazyLock;
use tracing::{error, info};

static CLIENT: LazyLock<Client> = LazyLock::new(reqwest::Client::new);

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    /// 需要爬取的古诗文网址，例如：https://www.gushiwen.cn/gushi/chuzhong.aspx
    url: String,
    /// 生成anki deck的名称
    #[arg(short, long)]
    name: Option<String>,
    /// 生成anki deck的描述
    #[arg(short, long)]
    desc: Option<String>,
    /// 生成anki deck的文件名
    #[arg(short, long)]
    filename: Option<String>,
    /// deck的类型（填空或正常，默认正常）
    #[arg(short, long)]
    r#type: Option<DeckType>,
    /// 是否删除内容内的括号（默认删除<->true）
    #[arg(short, long)]
    bracket: Option<bool>,
    /// 跳过长文依据字数（默认不跳过，可以用来跳过长文的填空）
    #[arg(short, long)]
    words: Option<usize>,
}
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum, Debug)]
enum DeckType {
    Simple,
    Cloze,
}
#[tokio::main]
async fn main() {
    tracing_subscriber::fmt::init();
    // parse_main_url(
    //     "https://www.gushiwen.cn/gushi/chuzhong.aspx",
    //     SimpleDeck::new("初中古诗文", "从[古诗文网](https://www.gushiwen.cn/gushi/chuzhong.aspx)爬取的初中古诗文集"),
    // )
    // .await;
    let args = Args::parse();
    let desc = if let Some(v) = args.desc {
        &v.to_owned()
    } else {
        if let Some(v) = args.words {
            &format!("Fetched from {} (Skip with more than {} words)\nGenerated by https://github.com/Initsnow/anki_chinese_poem_cards_generator", &args.url,v)
        } else {
            &format!("Fetched from {}\nGenerated by https://github.com/Initsnow/anki_chinese_poem_cards_generator", &args.url)
        }
    };
    let decktype = args.r#type.unwrap_or(DeckType::Simple);
    let bracket = args.bracket.unwrap_or(true);
    let name = &args.name.unwrap_or(get_main_title(&args.url).await);
    match decktype {
        DeckType::Simple => parse_main_url(
            &args.url,
            SimpleDeck::new(name, desc),
            if let Some(v) = &args.filename {
                v
            } else {
                name
            },
            decktype,
            bracket,
            args.words,
        )
        .await
        .unwrap(),
        DeckType::Cloze => parse_main_url(
            &args.url,
            ClozeDeck::new(name, desc),
            if let Some(v) = &args.filename {
                v
            } else {
                name
            },
            decktype,
            bracket,
            args.words,
        )
        .await
        .unwrap(),
    }
}
async fn get_main_title(url: &str) -> String {
    let res = CLIENT.get(url).send().await.unwrap().text().await.unwrap();
    let a = Html::parse_document(&res);
    a.select(&Selector::parse(".title h1").unwrap())
        .next()
        .unwrap()
        .text()
        .collect::<String>()
}
async fn parse_main_url<T: OwnDeck>(
    url: &str,
    mut deck: T,
    filename: &str,
    decktype: DeckType,
    bracket: bool,
    bypass_words: Option<usize>,
) -> Result<()> {
    let res = CLIENT.get(url).send().await?.text().await?;
    let a = Html::parse_document(&res);
    let split_selector = Selector::parse("div.typecont").unwrap();
    let split = a.select(&split_selector);
    let allcount = a
        .select(&Selector::parse("div.typecont span a").unwrap())
        .count();
    let pb = ProgressBar::new(allcount as u64);
    pb.set_style(ProgressStyle::with_template("{wide_bar} {pos}/{len} {msg}").unwrap());
    for i in split {
        let poem_url: Vec<String> = i
            .select(&Selector::parse("span a").unwrap())
            .map(|e| e.attr("href").unwrap().to_string())
            .collect();
        let split: Option<String> = i
            .select(&Selector::parse("div.bookMl strong").unwrap())
            .next()
            .map(|v| v.inner_html());
        // 判断是否为有标题分割的集
        if let Some(split_title) = split {
            deck.add_subdeck(&split_title, "");
            for relative_url in poem_url {
                let poetry = match get_poetry(
                    &format!("https://www.gushiwen.cn/{}", &relative_url),
                    decktype,
                    bracket,
                    bypass_words,
                )
                .await
                {
                    Ok(v) => v,
                    Err(e) => {
                        info!("{}", e.to_string());
                        continue;
                    }
                };
                if deck.add_note_to_subdeck(&poetry, &split_title) {
                    pb.set_message(format!(
                        "成功添加 {}——{} 到 {} deck",
                        poetry.title, poetry.author, split_title
                    ));
                    pb.inc(1);
                } else {
                    error!("添加{}失败, Url: {}", poetry.title, relative_url)
                };
                // sleep(Duration::from_secs_f32(0.1)).await;
            }
        } else {
            for relative_url in poem_url {
                let poetry = &get_poetry(
                    &format!("https://www.gushiwen.cn/{}", &relative_url),
                    decktype,
                    bracket,
                    bypass_words,
                )
                .await?;
                if deck.add_note(poetry).is_ok() {
                    pb.set_message(format!("成功添加 {}——{}", poetry.title, poetry.author));
                    pb.inc(1);
                } else {
                    error!("添加{}失败, Url: {}", poetry.title, relative_url)
                };
                // sleep(Duration::from_secs_f32(0.1)).await;
            }
        }
    }
    pb.finish_with_message("done");
    deck.write_to_file(&format!("{}.apkg", filename))?;
    info!("获取完毕，已写入文件...");

    Ok(())
}
async fn get_poetry(
    url: &str,
    contenttype: DeckType,
    bracket: bool,
    bypass_words: Option<usize>,
) -> Result<Poetry> {
    let html = Html::parse_document(&CLIENT.get(url).send().await?.text().await?);
    let title = html
        .select(&Selector::parse("div.cont h1").unwrap())
        .next()
        .unwrap()
        .inner_html();
    let sel = &Selector::parse("div.cont p.source a").unwrap();
    let mut tmp = html.select(sel);
    let author = tmp
        .next()
        .unwrap()
        .text()
        .filter_map(|x| {
            if !x.trim().is_empty() {
                Some(x.trim())
            } else {
                None
            }
        })
        .collect::<String>();
    let dynasty = tmp
        .next()
        .unwrap()
        .inner_html()
        .replace("〔", "")
        .replace("〕", "");
    let mut content = html
        .select(&Selector::parse("div.cont div.contson").unwrap())
        .next()
        .unwrap()
        .text()
        .collect::<Vec<_>>()
        .join("<br>");
    if let Some(v) = bypass_words {
        let c = words_count::count(&content).cjk;
        if c >= v {
            return Err(anyhow!("{}——{} 字数超出限制 {} >= {}", title, author, c, v));
        }
    }
    if let DeckType::Cloze = contenttype {
        content = parse_poetry_to_cloze(&content).await;
    }
    if bracket {
        let bracket_re = Regex::new(r"（.*?）|\(.*?\)").unwrap(); // 匹配中文和英文括号
        content = bracket_re.replace_all(&content, "").to_string();
    }
    Ok(Poetry::new(content, title, author, dynasty))
}
async fn parse_poetry_to_cloze(content: &str) -> String {
    // 移除括号内的文本（包括括号）
    let bracket_re = Regex::new(r"（.*?）|\(.*?\)").unwrap(); // 匹配中文和英文括号
    let cleaned_text = bracket_re.replace_all(content, "");

    // 按标点符号进行分割
    let re = Regex::new(r"([^，。！？；<br>\n“”]+)([，。！？；<br>\n“”]?)").unwrap();
    let mut counter = 1;

    // 替换为带 `{{cN::}}` 的格式
    let result = re.replace_all(&cleaned_text, |caps: &regex::Captures| {
        let text_part = &caps[1];
        let punctuation = &caps[2]; // 获取标点符号
        let new_str = format!("{{{{c{}::{}}}}}", counter, text_part);
        counter += 1;

        // 拼接文本和标点符号
        if punctuation.is_empty() {
            new_str
        } else {
            format!("{}{}", new_str, punctuation)
        }
    });
    result.to_string()
}
struct ClozeDeck {
    pub deck: Deck,
    name: String,
    pub subdeck: Option<Vec<ClozeDeck>>,
}
struct Poetry {
    content: String,
    title: String,
    author: String,
    dynasty: String,
}
impl Poetry {
    fn new(content: String, title: String, author: String, dynasty: String) -> Self {
        Poetry {
            content,
            title,
            author,
            dynasty,
        }
    }
}
impl ClozeDeck {
    fn new(name: &str, desc: &str) -> Self {
        let mut rng = rand::thread_rng();

        ClozeDeck {
            deck: Deck::new(rand::Rng::gen_range(&mut rng, 10000..100000), name, desc),
            name: String::from(name),
            subdeck: None,
        }
    }

    fn add_subdeck(&mut self, name: &str, desc: &str) {
        let mut rng = rand::thread_rng();
        if let Some(ref mut subdecks) = self.subdeck {
            subdecks.push(ClozeDeck {
                deck: Deck::new(
                    rand::Rng::gen_range(&mut rng, 10000..100000),
                    &format!("{}::{}", &self.name, name),
                    desc,
                ),
                name: String::from(name),
                subdeck: None,
            });
        } else {
            self.subdeck = Some(vec![ClozeDeck {
                deck: Deck::new(
                    rand::Rng::gen_range(&mut rng, 10000..100000),
                    &format!("{}::{}", &self.name, name),
                    desc,
                ),
                name: String::from(name),
                subdeck: None,
            }])
        }
    }

    fn collect_decks(&self) -> Vec<Deck> {
        let mut decks = vec![self.deck.clone()];
        if let Some(ref subdecks) = self.subdeck {
            // 遍历所有的 subdeck，并递归调用 collect_decks
            for subdeck in subdecks {
                decks.extend(subdeck.collect_decks());
            }
        }
        decks
    }
    fn model() -> Model {
        Model::new_with_options(
            16073923191231231,
            "诗词(填空)",
            vec![Field::new("内容"), Field::new("题目"), Field::new("作者"),Field::new("朝代")],
            vec![Template::new("Card 1")
                .qfmt(r#"<b>{{题目}}</b><span style="font-size: 16px">【{{朝代}}】{{作者}}</span><br>
    {{cloze:内容}}"#)
                .afmt(r#"<b>{{题目}}</b><span style="font-size: 16px">【{{朝代}}】{{作者}}</span><br>
    {{cloze:内容}}"#)],Some(
        ".card {\n font-family: 'LXGW Neo Zhisong','LXGW Neo Xihei','LXGW Neo WenKai',serif;\n font-size: 20px;\n text-align: center;\n color: black;\n background-color: white;\n}\n\n \
         .cloze {\n font-weight: bold;\n color: blue;\n}\n.nightMode .cloze {\n color: lightblue;\n}",
    ),
    Some(ModelType::Cloze),None,
    None,
    Some(1),
        )
    }
}

struct SimpleDeck {
    pub deck: Deck,
    name: String,
    pub subdeck: Option<Vec<SimpleDeck>>,
}

impl SimpleDeck {
    fn new(name: &str, desc: &str) -> Self {
        let mut rng = rand::thread_rng();

        SimpleDeck {
            deck: Deck::new(rand::Rng::gen_range(&mut rng, 10000..100000), name, desc),
            name: String::from(name),
            subdeck: None,
        }
    }

    fn add_subdeck(&mut self, name: &str, desc: &str) {
        let mut rng = rand::thread_rng();
        if let Some(ref mut subdecks) = self.subdeck {
            subdecks.push(Self {
                deck: Deck::new(
                    rand::Rng::gen_range(&mut rng, 10000..100000),
                    &format!("{}::{}", &self.name, name),
                    desc,
                ),
                name: String::from(name),
                subdeck: None,
            });
        } else {
            self.subdeck = Some(vec![Self {
                deck: Deck::new(
                    rand::Rng::gen_range(&mut rng, 10000..100000),
                    &format!("{}::{}", &self.name, name),
                    desc,
                ),
                name: String::from(name),
                subdeck: None,
            }])
        }
    }

    fn add_note_to_subdeck(&mut self, field: &Poetry, subdeck_name: &str) -> bool {
        if self.name == subdeck_name {
            // 如果当前 deck 名称匹配，添加 note
            let model = Self::model();
            let note = Note::new(
                model,
                vec![&field.content, &field.title, &field.author, &field.dynasty],
            )
            .unwrap();
            self.deck.add_note(note.clone());
            return true;
        }
        if let Some(ref mut subdecks) = self.subdeck {
            for subdeck in subdecks {
                if subdeck.add_note_to_subdeck(field, subdeck_name) {
                    return true;
                }
            }
        }
        false
    }
    fn write_to_file(&self, path: &str) -> Result<()> {
        if self.subdeck.is_none() {
            Ok(self.deck.write_to_file(path)?)
        } else {
            let decks = self.collect_decks();
            // dbg!(decks.len(),self.subdeck.as_ref().unwrap().len());
            Ok(genanki_rs::Package::new(decks, vec![])?.write_to_file(path)?)
        }
    }
    fn collect_decks(&self) -> Vec<Deck> {
        let mut decks = vec![self.deck.clone()];
        if let Some(ref subdecks) = self.subdeck {
            // 遍历所有的 subdeck，并递归调用 collect_decks
            for subdeck in subdecks {
                decks.extend(subdeck.collect_decks());
            }
        }
        decks
    }
    fn model() -> Model {
        Model::new_with_options(
            16073923191231230,
            "诗词",
            vec![
                Field::new("内容"),
                Field::new("题目"),
                Field::new("作者"),
                Field::new("朝代"),
            ],
            vec![Template::new("Card 1")
                .qfmt(r#"<b>{{题目}}</b><span style="font-size: 16px">【{{朝代}}】{{作者}}</span>"#)
                .afmt(
                    "{{FrontSide}}
                    <hr id=answer>
                    {{内容}}",
                )],
            Some(
                r#".card {
    font-family: "LXGW Neo Zhisong","LXGW Neo Xihei","LXGW Neo WenKai",serif;
    font-size: 20px;
    text-align: center;
    color: black;
    background-color: white;
}
"#,
            ),
            None,
            None,
            None,
            Some(1),
        )
    }
}

impl OwnDeck for SimpleDeck {
    fn add_subdeck(&mut self, name: &str, desc: &str) {
        let mut rng = rand::thread_rng();
        if let Some(ref mut subdecks) = self.subdeck {
            subdecks.push(Self {
                deck: Deck::new(
                    rand::Rng::gen_range(&mut rng, 10000..100000),
                    &format!("{}::{}", &self.name, name),
                    desc,
                ),
                name: String::from(name),
                subdeck: None,
            });
        } else {
            self.subdeck = Some(vec![Self {
                deck: Deck::new(
                    rand::Rng::gen_range(&mut rng, 10000..100000),
                    &format!("{}::{}", &self.name, name),
                    desc,
                ),
                name: String::from(name),
                subdeck: None,
            }])
        }
    }
    fn add_note_to_subdeck(&mut self, field: &Poetry, subdeck_name: &str) -> bool {
        if self.name == subdeck_name {
            // 如果当前 deck 名称匹配，添加 note
            let model = Self::model();
            let note = Note::new(
                model,
                vec![&field.content, &field.title, &field.author, &field.dynasty],
            )
            .unwrap();
            self.deck.add_note(note.clone());
            return true;
        }
        if let Some(ref mut subdecks) = self.subdeck {
            for subdeck in subdecks {
                if subdeck.add_note_to_subdeck(field, subdeck_name) {
                    return true;
                }
            }
        }
        false
    }
    fn write_to_file(&self, path: &str) -> Result<()> {
        if self.subdeck.is_none() {
            Ok(self.deck.write_to_file(path)?)
        } else {
            let decks = self.collect_decks();
            // dbg!(decks.len(),self.subdeck.as_ref().unwrap().len());
            Ok(genanki_rs::Package::new(decks, vec![])?.write_to_file(path)?)
        }
    }
    fn add_note(&mut self, field: &Poetry) -> Result<()> {
        let model = Self::model();
        let note = Note::new(
            model,
            vec![&field.content, &field.title, &field.author, &field.dynasty],
        )?;
        self.deck.add_note(note);
        Ok(())
    }
}
impl OwnDeck for ClozeDeck {
    fn add_subdeck(&mut self, name: &str, desc: &str) {
        let mut rng = rand::thread_rng();
        if let Some(ref mut subdecks) = self.subdeck {
            subdecks.push(Self {
                deck: Deck::new(
                    rand::Rng::gen_range(&mut rng, 10000..100000),
                    &format!("{}::{}", &self.name, name),
                    desc,
                ),
                name: String::from(name),
                subdeck: None,
            });
        } else {
            self.subdeck = Some(vec![Self {
                deck: Deck::new(
                    rand::Rng::gen_range(&mut rng, 10000..100000),
                    &format!("{}::{}", &self.name, name),
                    desc,
                ),
                name: String::from(name),
                subdeck: None,
            }])
        }
    }
    fn add_note_to_subdeck(&mut self, field: &Poetry, subdeck_name: &str) -> bool {
        if self.name == subdeck_name {
            // 如果当前 deck 名称匹配，添加 note
            let model = Self::model();
            let note = Note::new(
                model,
                vec![&field.content, &field.title, &field.author, &field.dynasty],
            )
            .unwrap();
            self.deck.add_note(note.clone());
            return true;
        }
        if let Some(ref mut subdecks) = self.subdeck {
            for subdeck in subdecks {
                if subdeck.add_note_to_subdeck(field, subdeck_name) {
                    return true;
                }
            }
        }
        false
    }
    fn write_to_file(&self, path: &str) -> Result<()> {
        if self.subdeck.is_none() {
            Ok(self.deck.write_to_file(path)?)
        } else {
            let decks = self.collect_decks();
            // dbg!(decks.len(),self.subdeck.as_ref().unwrap().len());
            Ok(genanki_rs::Package::new(decks, vec![])?.write_to_file(path)?)
        }
    }
    fn add_note(&mut self, field: &Poetry) -> Result<()> {
        let model = Self::model();
        let note = Note::new(
            model,
            vec![&field.content, &field.title, &field.author, &field.dynasty],
        )?;
        self.deck.add_note(note);
        Ok(())
    }
}
trait OwnDeck {
    fn add_subdeck(&mut self, name: &str, desc: &str);
    fn add_note_to_subdeck(&mut self, field: &Poetry, subdeck_name: &str) -> bool;
    fn write_to_file(&self, path: &str) -> Result<()>;
    fn add_note(&mut self, field: &Poetry) -> Result<()>;
}
